importVuefrom'vue'import{ref,h,nextTick,reactive}from'v3/index'reference:https:vue-composition-api-rfc.netlify.com/api.html#template-refsdescribe('api:setup()templaterefs',()=>{it('stringrefmount',()=>{constel=ref(null)constComp={setup(){return{refKey:el}},render(){returnh('div',{ref:'refKey'})}}constvm=newVue(Comp).$mount()expect(el.value).toBe(vm.$el)})it('stringrefupdate',async()=>{constfooEl=ref(null)constbarEl=ref(null)constrefKey=ref('foo')constComp={setup(){return{foo:fooEl,bar:barEl}},render(){returnh('div',{ref:refKey.value})}}constvm=newVue(Comp).$mount()expect(barEl.value).toBe(null)refKey.value='bar'awaitnextTick()expect(fooEl.value).toBe(null)expect(barEl.value).toBe(vm.$el)})it('stringrefunmount',async()=>{constel=ref(null)consttoggle=ref(true)constComp={setup(){return{refKey:el}},render(){returntoggle.value?h('div',{ref:'refKey'}):null}}constvm=newVue(Comp).$mount()expect(el.value).toBe(vm.$el)toggle.value=falseawaitnextTick()expect(el.value).toBe(null)})it('functionrefmount',()=>{constfn=vi.fn()constComp={render:()=>h('div',{ref:fn})}constvm=newVue(Comp).$mount()expect(fn.mock.calls[0][0]).toBe(vm.$el)})it('functionrefupdate',async()=>{constfn1=vi.fn()constfn2=vi.fn()constfn=ref(fn1)constComp={render:()=>h('div',{ref:fn.value})}constvm=newVue(Comp).$mount()expect(fn1.mock.calls).toHaveLength(1)expect(fn1.mock.calls[0][0]).toBe(vm.$el)expect(fn2.mock.calls).toHaveLength(0)fn.value=fn2awaitnextTick()expect(fn1.mock.calls).toHaveLength(2)expect(fn1.mock.calls[1][0]).toBe(null)expect(fn2.mock.calls).toHaveLength(1)expect(fn2.mock.calls[0][0]).toBe(vm.$el)})it('functionrefunmount',async()=>{constfn=vi.fn()consttoggle=ref(true)constComp={render:()=>(toggle.value?h('div',{ref:fn}):null)}constvm=newVue(Comp).$mount()expect(fn.mock.calls[0][0]).toBe(vm.$el)toggle.value=falseawaitnextTick()expect(fn.mock.calls[1][0]).toBe(null)})it('renderfunctionrefmount',()=>{constel=ref(null)constComp={setup(){return()=>h('div',{ref:el})}}constvm=newVue(Comp).$mount()expect(el.value).toBe(vm.$el)})it('renderfunctionrefupdate',async()=>{constrefs={foo:ref(null),bar:ref(null)}constrefKey=ref<keyoftypeofrefs>('foo')constComp={setup(){return()=>h('div',{ref:refs[refKey.value]})}}constvm=newVue(Comp).$mount()expect(refs.foo.value).toBe(vm.$el)expect(refs.bar.value).toBe(null)refKey.value='bar'awaitnextTick()expect(refs.foo.value).toBe(null)expect(refs.bar.value).toBe(vm.$el)})it('renderfunctionrefunmount',async()=>{constel=ref(null)consttoggle=ref(true)constComp={setup(){return()=>(toggle.value?h('div',{ref:el}):null)}}constvm=newVue(Comp).$mount()expect(el.value).toBe(vm.$el)toggle.value=falseawaitnextTick()expect(el.value).toBe(null)})it('stringrefinsideslots',async()=>{constspy=vi.fn()constChild={render(this:any){returnthis.$slots.default}}constComp={render(){returnh(Child,[h('div',{ref:'foo'})])},mounted(this:any){spy(this.$refs.foo.tagName)}}newVue(Comp).$mount()expect(spy).toHaveBeenCalledWith('DIV')})it('stringrefinsidescopedslots',async()=>{constspy=vi.fn()constChild={render(this:any){returnthis.$scopedSlots.default()}}constComp={render(){returnh(Child,{scopedSlots:{default:()=>[h('div',{ref:'foo'})]}})},mounted(this:any){spy(this.$refs.foo.tagName)}}newVue(Comp).$mount()expect(spy).toHaveBeenCalledWith('DIV')})it('shouldworkwithdirectreactiveproperty',()=>{conststate=reactive({refKey:null})constComp={setup(){returnstate},render(){returnh('div',{ref:'refKey'})}}constvm=newVue(Comp).$mount()expect(state.refKey).toBe(vm.$el)})test('multiplerefs',()=>{constrefKey1=ref(null)constrefKey2=ref(null)constrefKey3=ref(null)constComp={setup(){return{refKey1,refKey2,refKey3}},render(){returnh('div',[h('div',{ref:'refKey1'}),h('div',{ref:'refKey2'}),h('div',{ref:'refKey3'})])}}constvm=newVue(Comp).$mount()expect(refKey1.value).toBe(vm.$el.children[0])expect(refKey2.value).toBe(vm.$el.children[1])expect(refKey3.value).toBe(vm.$el.children[2])})vuejs/core#1505test('reactivetemplaterefinthesametemplate',async()=>{constComp={setup(){constel=ref()return{el}},render(this:any){returnh('div',{attrs:{id:'foo'},ref:'el'},this.el&&this.el.id)}}constvm=newVue(Comp).$mount()refnotreadyonfirstrender,butshouldqueueanupdateimmediatelyexpect(vm.$el.outerHTML).toBe(`<divid="foo"></div>`)awaitnextTick()refshouldbeupdatedexpect(vm.$el.outerHTML).toBe(`<divid="foo">foo</div>`)})vuejs/core#1834test('exchangerefs',async()=>{constrefToggle=ref(false)constspy=vi.fn()constComp={render(this:any){returnh('div',[h('p',{ref:refToggle.value?'foo':'bar'}),h('i',{ref:refToggle.value?'bar':'foo'})])},mounted(this:any){spy(this.$refs.foo.tagName,this.$refs.bar.tagName)},updated(this:any){spy(this.$refs.foo.tagName,this.$refs.bar.tagName)}}newVue(Comp).$mount()expect(spy.mock.calls[0][0]).toBe('I')expect(spy.mock.calls[0][1]).toBe('P')refToggle.value=trueawaitnextTick()expect(spy.mock.calls[1][0]).toBe('P')expect(spy.mock.calls[1][1]).toBe('I')})vuejs/core#1789test('togglethesamereftodifferentelements',async()=>{constrefToggle=ref(false)constspy=vi.fn()constComp={render(this:any){returnrefToggle.value?h('p',{ref:'foo'}):h('i',{ref:'foo'})},mounted(this:any){spy(this.$refs.foo.tagName)},updated(this:any){spy(this.$refs.foo.tagName)}}newVue(Comp).$mount()expect(spy.mock.calls[0][0]).toBe('I')refToggle.value=trueawaitnextTick()expect(spy.mock.calls[1][0]).toBe('P')})vuejs/core#2078@discrepancyVue2doesn'thandlemergerefstest('handlingmultiplemergedrefs',async()=>{constFoo={r:()=>h('div','foo')}constBar={rende=>h('div','bar')}constviewRef=shallowRef<any>(Foo)constelRef1=ref()constelRef2=ref()constApp={render(){f(!viewRef.value){returnnull}constview=h(viewRef.value,{ref:elRef1})returnh(view,{ref:elRef2})}}Vue(App).$mount()expect(elRef1.value.$el.innerHTML).toBe('foo')expect(elRef1.value).toBe(elRef2.value)viewRef.value=BarawaitnextTick()expect(elRef1.value.$el.innerHTML).toBe('bar')expect(elRef1.value).toBe(elRef2.value)viewRef.value=nullawaitnextTick()expect(elRef1.value).toBeNull()expect(elRef1.value).toBe(elRef2.value)})Vue2doesn'thaveinlinemodetest('rawrefwithref_key',()=>{letrefs:anyconstel=ref()constApp={mounted(){refsisasany).$refs},render(){retur'di{ref:el,ref_key:'el'},'hello')}}newVue(App).$mount/expect(el.value.innerHTML).toBe('hello')expect(refs.el.innerHTML).toBe('hello')})compiledoutputofv-for+templatereftest('refinv-for',async()=>{constshow=ref(true)conststate=reactive({list:[1,2,3]})constlistRefs=ref<any[]>([])constmapRefs=()=>listRefs.value.map(n=>n.innerHTML)constApp={render(){returnshow.value?h('ul',state.list.map(i=>h('li',{ref:listRefs,refInFor:true},i))):null}}newVue(App).$mount()expect(mapRefs()).toMatchObject(['1','2','3'])state.list.push(4)awaitnextTick()expect(mapRefs()).toMatchObject(['1','2','3','4'])state.list.shift()awaitnextTick()expect(mapRefs()).toMatchObject(['2','3','4'])show.value=!show.valueawaitnextTick()expect(mapRefs()).toMatchObject([])show.value=!show.valueawaitnextTick()expect(mapRefs()).toMatchObject(['2','3','4'])})test('namedrefinv-for',async()=>{constshow=ref(true)conststate=reactive({list:[1,2,3]})constlistRefs=ref([])constmapRefs=()=>listRefs.value.map((n:HTMLElement)=>n.innerHTML)constApp={setup(){return{listRefs}},render(){returnshow.value?h('ul',state.list.map(i=>h('li',{ref:'listRefs',refInFor:true},i))):null}}newVue(App).$mount()expect(mapRefs()).toMatchObject(['1','2','3'])state.list.push(4)awaitnextTick()expect(mapRefs()).toMatchObject(['1','2','3','4'])state.list.shift()awaitnextTick()expect(mapRefs()).toMatchObject(['2','3','4'])show.value=!show.valueawaitnextTick()expect(mapRefs()).toMatchObject([])show.value=!show.valueawaitnextTick()expect(mapRefs()).toMatchObject(['2','3','4'])})})