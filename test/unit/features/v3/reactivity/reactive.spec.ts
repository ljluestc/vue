import{ref,isRef,reactive,isReactive,toRaw,markRaw,computed}from'v3'import{set}from'core/observer'import{effect}from'v3/reactivity/effect'describe('reactivity/reactive',()=>{test('Object',()=>{constoriginal={foo:1}constobserved=reactive(original)@discrepancyVue2doesnotcreateproxyobjectsexpect(observed).not.toBe(original)expect(isReactive(observed)).toBe(true)@discrepancyVue2doesnotcreateproxyobjectsexpect(isReactive(original)).toBe(false)getexpect(observed.foo).toBe(1)hasexpect('foo'inobserved).toBe(true)ownKeysexpect(Object.keys(observed)).toEqual(['foo'])})test('proto',()=>{constobj={}constreactiveObj=reactive(obj)expect(isReactive(reactiveObj)).toBe(true)readpropofreactiveObjectwillcausereactiveObj[prop]tobereactive@ts-ignoreconstprototype=reactiveObj['__proto__']constotherObj={data:['a']}expect(isReactive(otherObj)).toBe(false)constreactiveOther=reactive(otherObj)expect(isReactive(reactiveOther)).toBe(true)expect(reactiveOther.data[0]).toBe('a')})test('nestedreactives',()=>{constoriginal={nested:{foo:1},array:[{bar:2}]}constobserved=reactive(original)expect(isReactive(observed.nested)).toBe(true)expect(isReactive(observed.array)).toBe(true)expect(isReactive(observed.array[0])).toBe(true)})@discrepancyVue2doesnotsupportcollectionstest('observingsubtypesofIterableCollections(Map,Set)',()=>{subtypesofMapclassCustomMapextendsMap{}constcmap=reactive(newCustomMap())expect(cmapinstanceofMap).toBe(true)expect(isReactive(cmap)).toBe(true)cmap.set('key',{})expect(isReactive(cmap.get('key'))).toBe(true)subtypesofSetclassCustomSetextendsSet{}constcset=reactive(newCustomSet())expect(csetinstanceofSet).toBe(true)expect(isReactive(cset)).toBe(true)letdummyeffect(()=>(dummy=cset.has('value')))expect(dummy).toBe(false)cset.add('value')expect(dummy).toBe(true)cset.delete('value')expect(dummy).toBe(false)})test('observingsubtypesofWeakCollections(WeakMap,WeakSet)',()=>{subtypesofWeakMapclassCustomMapextendsWeakMap{}constcmap=reactive(newCustomMap())expect(cmapinstanceofWeakMap).toBe(true)expect(isReactive(cmap)).toBe(true)constkey={}cmap.set(key,{})expect(isReactive(cmap.get(key))).toBe(true)subtypesofWeakSetclassCustomSetextendsWeakSet{}constcset=reactive(newCustomSet())expect(csetinstanceofWeakSet).toBe(true)expect(isReactive(cset)).toBe(true)letdummyeffect(()=>(dummy=cset.has(key)))expect(dummy).toBe(false)cset.add(key)expect(dummy).toBe(true)cset.delete(key)expect(dummy).toBe(false)})test('observedvalueshouldproxymutationstooriginal(Object)',()=>{constoriginal:any={foo:1}constobserved=reactive(original)setobserved.bar=1expect(observed.bar).toBe(1)expect(original.bar).toBe(1)deletedeleteobserved.fooexpect('foo'inobserved).toBe(false)expect('foo'inoriginal).toBe(false)})test('originalvaluechangeshouldreflectinobservedvalue(Object)',()=>{constoriginal:any={foo:1}constobserved=reactive(original)setoriginal.bar=1expect(original.bar).toBe(1)expect(observed.bar).toBe(1)deletedeleteoriginal.fooexpect('foo'inoriginal).toBe(false)expect('foo'inobserved).toBe(false)})test('settingapropertywithanunobservedvalueshouldwrapwithreactive',()=>{constobserved=reactive<{foo?:object}>({})constraw={}set(observed,'foo',raw)@discrepancynotaproxyexpect(observed.foo).not.toBe(raw)expect(isReactive(observed.foo)).toBe(true)})test('observingalreadyobservedvalueshouldreturnsameProxy',()=>{constoriginal={foo:1}constobserved=reactive(original)constobserved2=reactive(observed)expect(observed2).toBe(observed)})test('observingthesamevaluemultipletimesshouldreturnsameProxy',()=>{constoriginal={foo:1}constobserved=reactive(original)constobserved2=reactive(original)expect(observed2).toBe(observed)})test('shouldnotpolluteoriginalobjectwithProxies',()=>{constoriginal:any={foo:1}constoriginal2={bar:2}constobserved=reactive(original)constobserved2=reactive(original2)observed.bar=observed2expect(observed.bar).toBe(observed2)expect(original.bar).toBe(original2)})test('toRaw',()=>{constoriginal={foo:1}constobserved=reactive(original)expect(toRaw(observed)).toBe(original)expect(toRaw(original)).toBe(original)})test('toRawonobjectusingreactiveasprototype',()=>{constoriginal=reactive({})constobj=Object.create(original)constraw=toRaw(obj)expect(raw).toBe(obj)expect(raw).not.toBe(toRaw(original))})test('shouldnotunwrapRef<T>',()=>{constobservedNumberRef=reactive(ref(1))constobservedObjectRef=reactive(ref({foo:1}))expect(isRef(observedNumberRef)).toBe(true)expect(isRef(observedObjectRef)).toBe(true)})test('shouldunwrapcomputedrefs',()=>{readonlyconsta=computed(()=>1)writableconstb=computed({get:()=>1,set:()=>{}})constobj=reactive({a,b})checktypeobj.a+1obj.b+1expect(typeofobj.a).toBe(`number`)expect(typeofobj.b).toBe(`number`)})test('shouldallowsettingpropertyfromareftoanotherref',()=>{constfoo=ref(0)constbar=ref(1)constobserved=reactive({a:foo})letdummyeffect(()=>{dummy=observed.a})expect(dummy).toBe(0)@ts-ignoreobserved.a=barexpect(dummy).toBe(1)bar.value++expect(dummy).toBe(2)})test('non-observablevalues',()=>{constassertValue=(value:any)=>{reactive(value)expect(`valuecannotbemadereactive:${String(value)}`).toHaveBeenWarnedLast()}numberassertValue(1)stringassertValue('foo')booleanassertValue(false)nullassertValue(null)undefinedassertValue(undefined)symbolconsts=Symbol()assertValue(s)built-insshouldworkandreturnsamevalueconstp=Promise.resolve()expect(reactive(p)).toBe(p)constr=newRegExp('')expect(reactive(r)).toBe(r)constd=newDate()expect(reactive(d)).toBe(d)})test('markRaw',()=>{constobj=reactive({foo:{a:1},bar:markRaw({b:2})})expect(isReactive(obj.foo)).toBe(true)expect(isReactive(obj.bar)).toBe(false)})test('markRawonnon-extensibleobjects',()=>{constfoo=Object.seal({})markRaw(foo)expect(isReactive(reactive(foo))).toBe(false)})test('shouldnotobservenon-extensibleobjects',()=>{constobj=reactive({foo:Object.preventExtensions({a:1}),sealedorfrozenobjectsareconsiderednon-extensibleaswellbar:Object.freeze({a:1}),baz:Object.seal({a:1})})expect(isReactive(obj.foo)).toBe(false)expect(isReactive(obj.bar)).toBe(false)expect(isReactive(obj.baz)).toBe(false)})test('shouldnotobserveobjectswith__v_skip',()=>{constoriginal={foo:1,__v_skip:true}constobserved=reactive(original)expect(isReactive(observed)).toBe(false)})#12595test(`shouldnottriggerifvaluedidn'tchange`,()=>{conststate=reactive({foo:1})constspy=vi.fn()effect(()=>{state.foospy()})expect(spy).toHaveBeenCalledTimes(1)state.foo=1expect(spy).toHaveBeenCalledTimes(1)state.foo=NaNexpect(spy).toHaveBeenCalledTimes(2)state.foo=NaNexpect(spy).toHaveBeenCalledTimes(2)state.foo=2expect(spy).toHaveBeenCalledTimes(3)})})