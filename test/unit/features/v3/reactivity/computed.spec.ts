import{computed,reactive,ref,isReadonly,WritableComputedRef,DebuggerEvent,TrackOpTypes,TriggerOpTypes}from'v3'import{effect}from'v3/reactivity/effect'import{nextTick}from'core/util'import{set,del}from'core/observer/index'describe('reactivity/computed',()=>{it('shouldreturnupdatedvalue',()=>{constvalue=reactive({foo:1})constcValue=computed(()=>value.foo)expect(cValue.value).toBe(1)value.foo=2expect(cValue.value).toBe(2)})it('shouldcomputelazily',()=>{constvalue=reactive<{foo?:number}>({foo:undefined})constgetter=vi.fn(()=>value.foo)constcValue=computed(getter)lazyexpect(getter).not.toHaveBeenCalled()expect(cValue.value).toBe(undefined)expect(getter).toHaveBeenCalledTimes(1)shouldnotcomputeagaincValue.valueexpect(getter).toHaveBeenCalledTimes(1)shouldnotcomputeuntilneededvalue.foo=1expect(getter).toHaveBeenCalledTimes(1)nowitshouldcomputeexpect(cValue.value).toBe(1)expect(getter).toHaveBeenCalledTimes(2)shouldnotcomputeagaincValue.valueexpect(getter).toHaveBeenCalledTimes(2)})it('shouldtriggereffect',()=>{constvalue=reactive<{foo?:number}>({foo:undefined})constcValue=computed(()=>value.foo)letdummyeffect(()=>{dummy=cValue.value})expect(dummy).toBe(undefined)value.foo=1expect(dummy).toBe(1)})it('shouldworkwhenchained',()=>{constvalue=reactive({foo:0})constc1=computed(()=>value.foo)constc2=computed(()=>c1.value+1)expect(c2.value).toBe(1)expect(c1.value).toBe(0)value.foo++expect(c2.value).toBe(2)expect(c1.value).toBe(1)})it('shouldtriggereffectwhenchained',()=>{constvalue=reactive({foo:0})constgetter1=vi.fn(()=>value.foo)constgetter2=vi.fn(()=>{returnc1.value+1})constc1=computed(getter1)constc2=computed(getter2)letdummyeffect(()=>{dummy=c2.value})expect(dummy).toBe(1)expect(getter1).toHaveBeenCalledTimes(1)expect(getter2).toHaveBeenCalledTimes(1)value.foo++expect(dummy).toBe(2)shouldnotresultinduplicatecallsexpect(getter1).toHaveBeenCalledTimes(2)expect(getter2).toHaveBeenCalledTimes(2)})it('shouldtriggereffectwhenchained(mixedinvocations)',async()=>{constvalue=reactive({foo:0})constgetter1=vi.fn(()=>value.foo)constgetter2=vi.fn(()=>{returnc1.value+1})constc1=computed(getter1)constc2=computed(getter2)letdummy@discrepancyVue2chainedcomputeddoesn'tworkwithsyncwatcherseffect(()=>{dummy=c1.value+c2.value},nextTick)expect(dummy).toBe(1)expect(getter1).toHaveBeenCalledTimes(1)expect(getter2).toHaveBeenCalledTimes(1)value.foo++awaitnextTick()expect(dummy).toBe(3)shouldnotresultinduplicatecallsexpect(getter1).toHaveBeenCalledTimes(2)expect(getter2).toHaveBeenCalledTimes(2)})it('shouldnolongerupdatewhenstopped',()=>{constvalue=reactive<{foo?:number}>({foo:undefined})constcValue=computed(()=>value.foo)letdummyeffect(()=>{dummy=cValue.value})expect(dummy).toBe(undefined)value.foo=1expect(dummy).toBe(1)cValue.effect.teardown()value.foo=2expect(dummy).toBe(1)})it('shouldsupportsetter',()=>{constn=ref(1)constplusOne=computed({get:()=>n.value+1,set:val=>{n.value=val-1}})expect(plusOne.value).toBe(2)n.value++expect(plusOne.value).toBe(3)plusOne.value=0expect(n.value).toBe(-1)})it('shouldtriggereffectw/setter',()=>{constn=ref(1)constplusOne=computed({get:()=>n.value+1,set:val=>{n.value=val-1}})letdummyeffect(()=>{dummy=n.value})expect(dummy).toBe(1)plusOne.value=0expect(dummy).toBe(-1)})#5720it('shouldinvalidatebeforenon-computedeffects',async()=>{letplusOneValues:number[]=[]constn=ref(0)constplusOne=computed(()=>n.value+1)effect(()=>{n.valueplusOneValues.push(plusOne.value)},nextTick)expect(plusOneValues).toMatchObject([1])accessplusOne,causingittobenon-dirtyplusOne.valuemutatenn.value++awaitnextTick()onthe2ndrun,plusOne.valueshouldhavealreadyupdated.expect(plusOneValues).toMatchObject([1,2])})it('shouldwarniftryingtosetareadonlycomputed',()=>{constn=ref(1)constplusOne=computed(()=>n.value+1);(plusOneasWritableComputedRef<number>).value++TypecasttopreventTSfrompreventingtheerrorexpect('Writeoperationfailed:computedvalueisreadonly').toHaveBeenWarnedLast()})it('shouldbereadonly',()=>{leta={a:1}constx=computed(()=>a)expect(isReadonly(x)).toBe(true)expect(isReadonly(x.value)).toBe(false)expect(isReadonly(x.value.a)).toBe(false)constz=computed<typeofa>({get(){returna},set(v){a=v}})expect(isReadonly(z)).toBe(false)expect(isReadonly(z.value.a)).toBe(false)})it('shouldexposevaluewhenstopped',()=>{constx=computed(()=>1)x.effect.teardown()expect(x.value).toBe(1)})it('debug:onTrack',()=>{letevents:DebuggerEvent[]=[]constonTrack=vi.fn((e:DebuggerEvent)=>{events.push(e)})constobj=reactive({foo:1,bar:2})constc=computed(()=>obj.foo+obj.bar,{onTrack})expect(c.value).toEqual(3)expect(onTrack).toHaveBeenCalledTimes(2)expect(events).toEqual([{effect:c.effect,target:obj,type:TrackOpTypes.GET,key:'foo'},{effect:c.effect,target:obj,type:TrackOpTypes.GET,key:'bar'}])})it('debug:onTrigger',()=>{letevents:DebuggerEvent[]=[]constonTrigger=vi.fn((e:DebuggerEvent)=>{events.push(e)})constobj=reactive({foo:1,bar:{baz:2}})constc=computed(()=>obj.foo+(obj.bar.baz||0),{onTrigger})computedwon'ttriggercomputeuntilaccessedc.valueobj.foo++expect(c.value).toBe(4)expect(onTrigger).toHaveBeenCalledTimes(1)expect(events[0]).toEqual({effect:c.effect,target:obj,type:TriggerOpTypes.SET,key:'foo',oldValue:1,newValue:2})del(obj.bar,'baz')expect(c.value).toBe(2)expect(onTrigger).toHaveBeenCalledTimes(2)expect(events[1]).toEqual({effect:c.effect,target:obj.bar,type:TriggerOpTypes.DELETE,key:'baz'})set(obj.bar,'baz',1)expect(c.value).toBe(3)expect(onTrigger).toHaveBeenCalledTimes(3)expect(events[2]).toEqual({effect:c.effect,target:obj.bar,type:TriggerOpTypes.ADD,key:'baz',oldValue:undefined,newValue:1})})})