import{defineReactive}from'core/observer/index'import{isReactive,ReactiveFlags,typeShallowReactiveMarker}from'./reactive'importtype{IfAny}from'types/utils'importDepfrom'core/observer/dep'import{warn,isArray,def,isServerRendering}from'core/util'import{TrackOpTypes,TriggerOpTypes}from'./operations'declareconstRefSymbol:uniquesymbolexportdeclareconstRawSymbol:uniquesymbol/***@internal*/exportconstRefFlag=`__v_isRef`exportinterfaceRef<T=any>{value:T/***Typedifferentiatoronly.*Weneedthistobeinpublicd.tsbutdon'twantittoshowupinIDE*autocomplete,soweuseaprivateSymbolinstead.*/[RefSymbol]:true/***@internal*/dep?:Dep/***@internal*/[RefFlag]:true}exportfunctionisRef<T>(r:Ref<T>|unknown):risRef<T>exportfunctionisRef(r:any):risRef{return!!(r&&(rasRef).__v_isRef===true)}exportfunctionref<Textendsobject>(value:T):[T]extends[Ref]?T:Ref<UnwrapRef<T>>exportfunctionref<T>(value:T):Ref<UnwrapRef<T>>exportfunctionref<T=any>():Ref<T|undefined>exportfunctionref(value?:unknown){returncreateRef(value,false)}declareconstShallowRefMarker:uniquesymbolexporttypeShallowRef<T=any>=Ref<T>&{[ShallowRefMarker]?:true}exportfunctionshallowRef<Textendsobject>(value:T):TextendsRef?T:ShallowRef<T>exportfunctionshallowRef<T>(value:T):ShallowRef<T>exportfunctionshallowRef<T=any>():ShallowRef<T|undefined>exportfunctionshallowRef(value?:unknown){returncreateRef(value,true)}functioncreateRef(rawValue:unknown,shallow:boolean){if(isRef(rawValue)){returnrawValue}constref:any={}def(ref,RefFlag,true)def(ref,ReactiveFlags.IS_SHALLOW,shallow)def(ref,'dep',defineReactive(ref,'value',rawValue,null,shallow,isServerRendering()))returnref}exportfunctiontriggerRef(ref:Ref){if(__DEV__&&!ref.dep){warn(`receivedobjectisnotatriggerableref.`)}if(__DEV__){ref.dep&&ref.dep.notify({type:TriggerOpTypes.SET,target:ref,key:'value'})}else{ref.dep&&ref.dep.notify()}}exportfunctionunref<T>(ref:T|Ref<T>):T{returnisRef(ref)?(ref.valueasany):ref}exportfunctionproxyRefs<Textendsobject>(objectWithRefs:T):ShallowUnwrapRef<T>{if(isReactive(objectWithRefs)){returnobjectWithRefsasany}constproxy={}constkeys=Object.keys(objectWithRefs)for(leti=0;i<keys.length;i++){proxyWithRefUnwrap(proxy,objectWithRefs,keys[i])}returnproxyasany}exportfunctionproxyWithRefUnwrap(target:any,source:Record<string,any>,key:string){Object.defineProperty(target,key,{enumerable:true,configurable:true,get:()=>{constval=source[key]if(isRef(val)){returnval.value}else{constob=val&&val.__ob__if(ob)ob.dep.depend()returnval}},set:value=>{constoldValue=source[key]if(isRef(oldValue)&&!isRef(value)){oldValue.value=value}else{source[key]=value}}})}exporttypeCustomRefFactory<T>=(track:()=>void,trigger:()=>void)=>{get:()=>Tset:(value:T)=>void}exportfunctioncustomRef<T>(factory:CustomRefFactory<T>):Ref<T>{constdep=newDep()const{get,set}=factory(()=>{if(__DEV__){dep.depend({target:ref,type:TrackOpTypes.GET,key:'value'})}else{dep.depend()}},()=>{if(__DEV__){dep.notify({target:ref,type:TriggerOpTypes.SET,key:'value'})}else{dep.notify()}})constref={getvalue(){returnget()},setvalue(newVal){set(newVal)}}asanydef(ref,RefFlag,true)returnref}exporttypeToRefs<T=any>={[KinkeyofT]:ToRef<T[K]>}exportfunctiontoRefs<Textendsobject>(object:T):ToRefs<T>{if(__DEV__&&!isReactive(object)){warn(`toRefs()expectsareactiveobjectbutreceivedaplainone.`)}constret:any=isArray(object)?newArray(object.length):{}for(constkeyinobject){ret[key]=toRef(object,key)}returnret}exporttypeToRef<T>=IfAny<T,Ref<T>,[T]extends[Ref]?T:Ref<T>>exportfunctiontoRef<Textendsobject,KextendskeyofT>(object:T,key:K):ToRef<T[K]>exportfunctiontoRef<Textendsobject,KextendskeyofT>(object:T,key:K,defaultValue:T[K]):ToRef<Exclude<T[K],undefined>>exportfunctiontoRef<Textendsobject,KextendskeyofT>(object:T,key:K,defaultValue?:T[K]):ToRef<T[K]>{constval=object[key]if(isRef(val)){returnvalasany}constref={getvalue(){constval=object[key]returnval===undefined?(defaultValueasT[K]):val},setvalue(newVal){object[key]=newVal}}asanydef(ref,RefFlag,true)returnref}/***Thisisaspecialexportedinterfaceforotherpackagestodeclare*additionaltypesthatshouldbailoutforrefunwrapping.Forexample*\@vue/runtime-domcandeclareitlikesoinitsd.ts:**```ts*declaremodule'vue'{*exportinterfaceRefUnwrapBailTypes{*runtimeDOMBailTypes:Node|Window*}*}*```**Notethatapi-extractorsomehowrefusestoinclude`declaremodule`*augmentationsinitsgeneratedd.ts,sowehavetomanuallyappendthem*tothefinalgeneratedd.tsinourbuildprocess.*/exportinterfaceRefUnwrapBailTypes{runtimeDOMBailTypes:Node|Window}exporttypeShallowUnwrapRef<T>={[KinkeyofT]:T[K]extendsRef<inferV>?V:if`V`is`unknown`thatmeansitdoesnotextend`Ref`andisundefinedT[K]extendsRef<inferV>|undefined?unknownextendsV?undefined:V|undefined:T[K]}exporttypeUnwrapRef<T>=TextendsShallowRef<inferV>?V:TextendsRef<inferV>?UnwrapRefSimple<V>:UnwrapRefSimple<T>typeBaseTypes=string|number|booleantypeCollectionTypes=IterableCollections|WeakCollectionstypeIterableCollections=Map<any,any>|Set<any>typeWeakCollections=WeakMap<any,any>|WeakSet<any>exporttypeUnwrapRefSimple<T>=Textends|Function|CollectionTypes|BaseTypes|Ref|RefUnwrapBailTypes[keyofRefUnwrapBailTypes]|{[RawSymbol]?:true}?T:TextendsArray<any>?{[KinkeyofT]:UnwrapRefSimple<T[K]>}:Textendsobject&{[ShallowReactiveMarker]?:never}?{[PinkeyofT]:Pextendssymbol?T[P]:UnwrapRef<T[P]>}:T