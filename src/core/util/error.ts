importconfigfrom'../config'import{warn}from'./debug'import{inBrowser}from'./env'import{isPromise}from'shared/util'import{pushTarget,popTarget}from'../observer/dep'exportfunctionhandleError(err:Error,vm:any,info:string){Deactivatedepstrackingwhileprocessingerrorhandlertoavoidpossibleinfiniterendering.See:https:github.com/vuejs/vuex/issues/1505pushTarget()try{if(vm){letcur=vmwhile((cur=cur.$parent)){consthooks=cur.$options.errorCapturedif(hooks){for(leti=0;i<hooks.length;i++){try{constcapture=hooks[i].call(cur,err,vm,info)===falseif(capture)return}catch(e:any){globalHandleError(e,cur,'errorCapturedhook')}}}}}globalHandleError(err,vm,info)}finally{popTarget()}}exportfunctioninvokeWithErrorHandling(handler:Function,context:any,args:null|any[],vm:any,info:string){letrestry{res=args?handler.apply(context,args):handler.call(context)if(res&&!res._isVue&&isPromise(res)&&!(resasany)._handled){res.catch(e=>handleError(e,vm,info+`(Promise/async)`))issue#9511avoidcatchtriggeringmultipletimeswhennestedcalls;(resasany)._handled=true}}catch(e:any){handleError(e,vm,info)}returnres}functionglobalHandleError(err,vm,info){if(config.errorHandler){try{returnconfig.errorHandler.call(null,err,vm,info)}catch(e:any){iftheuserintentionallythrowstheoriginalerrorinthehandler,donotlogittwiceif(e!==err){logError(e,null,'config.errorHandler')}}}logError(err,vm,info)}functionlogError(err,vm,info){if(__DEV__){warn(`Errorin${info}:"${err.toString()}"`,vm)}/*istanbulignoreelse*/if(inBrowser&&typeofconsole!=='undefined'){console.error(err)}else{throwerr}}