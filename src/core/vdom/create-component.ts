importVNodefrom'./vnode'import{isArray}from'core/util'import{resolveConstructorOptions}from'core/instance/init'import{queueActivatedComponent}from'core/observer/scheduler'import{createFunctionalComponent}from'./create-functional-component'import{warn,isDef,isUndef,isTrue,isObject}from'../util/index'import{resolveAsyncComponent,createAsyncPlaceholder,extractPropsFromVNodeData}from'./helpers/index'import{callHook,activeInstance,updateChildComponent,activateChildComponent,deactivateChildComponent}from'../instance/lifecycle'importtype{MountedComponentVNode,VNodeData,VNodeWithData}from'types/vnode'importtype{Component}from'types/component'importtype{ComponentOptions,InternalComponentOptions}from'types/options'exportfunctiongetComponentName(options:ComponentOptions){returnoptions.name||options.__name||options._componentTag}//inlinehookstobeinvokedoncomponentVNodesduringpatchconstcomponentVNodeHooks={init(vnode:VNodeWithData,hydrating:boolean):boolean|void{if(vnode.componentInstance&&!vnode.componentInstance._isDestroyed&&vnode.data.keepAlive){//kept-alivecomponents,treatasapatchconstmountedNode:any=vnode//workaroundflowcomponentVNodeHooks.prepatch(mountedNode,mountedNode)}else{constchild=(vnode.componentInstance=createComponentInstanceForVnode(vnode,activeInstance))child.$mount(hydrating?vnode.elm:undefined,hydrating)}},prepatch(oldVnode:MountedComponentVNode,vnode:MountedComponentVNode){constoptions=vnode.componentOptionsconstchild=(vnode.componentInstance=oldVnode.componentInstance)updateChildComponent(child,options.propsData,//updatedpropsoptions.listeners,//updatedlistenersvnode,//newparentvnodeoptions.children//newchildren)},insert(vnode:MountedComponentVNode){const{context,componentInstance}=vnodeif(!componentInstance._isMounted){componentInstance._isMounted=truecallHook(componentInstance,'mounted')}if(vnode.data.keepAlive){if(context._isMounted){//vue-router#1212//Duringupdates,akept-alivecomponent'schildcomponentsmay//change,sodirectlywalkingthetreeheremaycallactivatedhooks//onincorrectchildren.Insteadwepushthemintoaqueuewhichwill//beprocessedafterthewholepatchprocessended.queueActivatedComponent(componentInstance)}else{activateChildComponent(componentInstance,true/*direct*/)}}},destroy(vnode:MountedComponentVNode){const{componentInstance}=vnodeif(!componentInstance._isDestroyed){if(!vnode.data.keepAlive){componentInstance.$destroy()}else{deactivateChildComponent(componentInstance,true/*direct*/)}}}}consthooksToMerge=Object.keys(componentVNodeHooks)exportfunctioncreateComponent(Ctor:typeofComponent|Function|ComponentOptions|void,data:VNodeData|undefined,context:Component,children?:Array<VNode>,tag?:string):VNode|Array<VNode>|void{if(isUndef(Ctor)){return}constbaseCtor=context.$options._base//plainoptionsobject:turnitintoaconstructorif(isObject(Ctor)){Ctor=baseCtor.extend(CtorastypeofComponent)}//ifatthisstageit'snotaconstructororanasynccomponentfactory,//reject.if(typeofCtor!=='function'){if(__DEV__){warn(`InvalidComponentdefinition:${String(Ctor)}`,context)}return}//asynccomponentletasyncFactory//@ts-expect-errorif(isUndef(Ctor.cid)){asyncFactory=CtorCtor=resolveAsyncComponent(asyncFactory,baseCtor)if(Ctor===undefined){//returnaplaceholdernodeforasynccomponent,whichisrendered//asacommentnodebutpreservesalltherawinformationforthenode.//theinformationwillbeusedforasyncserver-renderingandhydration.returncreateAsyncPlaceholder(asyncFactory,data,context,children,tag)}}data=data||{}//resolveconstructoroptionsincaseglobalmixinsareappliedafter//componentconstructorcreationresolveConstructorOptions(CtorastypeofComponent)//transformcomponentv-modeldataintoprops&eventsif(isDef(data.model)){//@ts-expect-errortransformModel(Ctor.options,data)}//extractprops//@ts-expect-errorconstpropsData=extractPropsFromVNodeData(data,Ctor,tag)//functionalcomponent//@ts-expect-errorif(isTrue(Ctor.options.functional)){returncreateFunctionalComponent(CtorastypeofComponent,propsData,data,context,children)}//extractlisteners,sincetheseneedstobetreatedas//childcomponentlistenersinsteadofDOMlistenersconstlisteners=data.on//replacewithlistenerswith.nativemodifier//soitgetsprocessedduringparentcomponentpatch.data.on=data.nativeOn//@ts-expect-errorif(isTrue(Ctor.options.abstract)){//abstractcomponentsdonotkeepanything//otherthanprops&listeners&slot//workaroundflowconstslot=data.slotdata={}if(slot){data.slot=slot}}//installcomponentmanagementhooksontotheplaceholdernodeinstallComponentHooks(data)//returnaplaceholdervnode//@ts-expect-errorconstname=getComponentName(Ctor.options)||tagconstvnode=newVNode(//@ts-expect-error`vue-component-${Ctor.cid}${name?`-${name}`:''}`,data,undefined,undefined,undefined,context,//@ts-expect-error{Ctor,propsData,listeners,tag,children},asyncFactory)returnvnode}exportfunctioncreateComponentInstanceForVnode(//weknowit'sMountedComponentVNodebutflowdoesn'tvnode:any,//activeInstanceinlifecyclestateparent?:any):Component{constoptions:InternalComponentOptions={_isComponent:true,_parentVnode:vnode,parent}//checkinline-templaterenderfunctionsconstinlineTemplate=vnode.data.inlineTemplateif(isDef(inlineTemplate)){options.render=inlineTemplate.renderoptions.staticRenderFns=inlineTemplate.staticRenderFns}returnnewvnode.componentOptions.Ctor(options)}functioninstallComponentHooks(data:VNodeData){consthooks=data.hook||(data.hook={})for(leti=0;i<hooksToMerge.length;i++){constkey=hooksToMerge[i]constexisting=hooks[key]consttoMerge=componentVNodeHooks[key]//@ts-expect-errorif(existing!==toMerge&&!(existing&&existing._merged)){hooks[key]=existing?mergeHook(toMerge,existing):toMerge}}}functionmergeHook(f1:any,f2:any):Function{constmerged=(a,b)=>{//flowcomplainsaboutextraargswhichiswhyweuseanyf1(a,b)f2(a,b)}merged._merged=truereturnmerged}//transformcomponentv-modelinfo(valueandcallback)into//propandeventhandlerrespectively.functiontransformModel(options,data:any){constprop=(options.model&&options.model.prop)||'value'constevent=(options.model&&options.model.event)||'input';(data.attrs||(data.attrs={}))[prop]=data.model.valueconston=data.on||(data.on={})constexisting=on[event]constcallback=data.model.callbackif(isDef(existing)){if(isArray(existing)?existing.indexOf(callback)===-1:existing!==callback){on[event]=[callback].concat(existing)}}else{on[event]=callback}}