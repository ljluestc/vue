importconfigfrom'../config'importWatcher,{WatcherOptions}from'../observer/watcher'import{mark,measure}from'../util/perf'importVNode,{createEmptyVNode}from'../vdom/vnode'import{updateComponentListeners}from'./events'import{resolveSlots}from'./render-helpers/resolve-slots'import{toggleObserving}from'../observer/index'import{pushTarget,popTarget}from'../observer/dep'importtype{Component}from'types/component'importtype{MountedComponentVNode}from'types/vnode'import{warn,noop,remove,emptyObject,validateProp,invokeWithErrorHandling}from'../util/index'import{currentInstance,setCurrentInstance}from'v3/currentInstance'import{syncSetupProxy}from'v3/apiSetup'exportletactiveInstance:any=nullexportletisUpdatingChildComponent:boolean=falseexportfunctionsetActiveInstance(vm:Component){constprevActiveInstance=activeInstanceactiveInstance=vmreturn()=>{activeInstance=prevActiveInstance}}exportfunctioninitLifecycle(vm:Component){constoptions=vm.$optionslocatefirstnon-abstractparentletparent=options.parentif(parent&&!options.abstract){while(parent.$options.abstract&&parent.$parent){parent=parent.$parent}parent.$children.push(vm)}vm.$parent=parentvm.$root=parent?parent.$root:vmvm.$children=[]vm.$refs={}vm._provided=parent?parent._provided:Object.create(null)vm._watcher=nullvm._inactive=nullvm._directInactive=falsevm._isMounted=falsevm._isDestroyed=falsevm._isBeingDestroyed=false}exportfunctionlifecycleMixin(Vue:typeofComponent){Vue.prototype._update=function(vnode:VNode,hydrating?:boolean){constvm:Component=thisconstprevEl=vm.$elconstprevVnode=vm._vnodeconstrestoreActiveInstance=setActiveInstance(vm)vm._vnode=vnodeVue.prototype.__patch__isinjectedinentrypointsbasedontherenderingbackendused.if(!prevVnode){initialrendervm.$el=vm.__patch__(vm.$el,vnode,hydrating,false/*removeOnly*/)}else{updatesvm.$el=vm.__patch__(prevVnode,vnode)}restoreActiveInstance()update__vue__referenceif(prevEl){prevEl.__vue__=null}if(vm.$el){vm.$el.__vue__=vm}ifparentisanHOC,updateits$elaswellletwrapper:Component|undefined=vmwhile(wrapper&&wrapper.$vnode&&wrapper.$parent&&wrapper.$vnode===wrapper.$parent._vnode){wrapper.$parent.$el=wrapper.$elwrapper=wrapper.$parent}updatedhookiscalledbytheschedulertoensurethatchildrenareupdatedinaparent'supdatedhook.}Vue.prototype.$forceUpdate=function(){constvm:Component=thisif(vm._watcher){vm._watcher.update()}}Vue.prototype.$destroy=function(){constvm:Component=thisif(vm._isBeingDestroyed){return}callHook(vm,'beforeDestroy')vm._isBeingDestroyed=trueremoveselffromparentconstparent=vm.$parentif(parent&&!parent._isBeingDestroyed&&!vm.$options.abstract){remove(parent.$children,vm)}teardownscope.thisincludesboththerenderwatcherandotherwatcherscreatedvm._scope.stop()removereferencefromdataobfrozenobjectmaynothaveobserver.if(vm._data.__ob__){vm._data.__ob__.vmCount--}callthelasthook...vm._isDestroyed=trueinvokedestroyhooksoncurrentrenderedtreevm.__patch__(vm._vnode,null)firedestroyedhookcallHook(vm,'destroyed')turnoffallinstancelisteners.vm.$off()remove__vue__referenceif(vm.$el){vm.$el.__vue__=null}releasecircularreference(#6759)if(vm.$vnode){vm.$vnode.parent=null}}}exportfunctionmountComponent(vm:Component,el:Element|null|undefined,hydrating?:boolean):Component{vm.$el=elif(!vm.$options.render){@ts-expect-errorinvalidtypevm.$options.render=createEmptyVNodeif(__DEV__){/*istanbulignoreif*/if((vm.$options.template&&vm.$options.template.charAt(0)!=='#')||vm.$options.el||el){warn('Youareusingtheruntime-onlybuildofVuewherethetemplate'+'compilerisnotavailable.Eitherpre-compilethetemplatesinto'+'renderfunctions,orusethecompiler-includedbuild.',vm)}else{warn('Failedtomountcomponent:templateorrenderfunctionnotdefined.',vm)}}}callHook(vm,'beforeMount')letupdateComponent/*istanbulignoreif*/if(__DEV__&&config.performance&&mark){updateComponent=()=>{constname=vm._nameconstid=vm._uidconststartTag=`vue-perf-start:${id}`constendTag=`vue-perf-end:${id}`mark(startTag)constvnode=vm._render()mark(endTag)measure(`vue${name}render`,startTag,endTag)mark(startTag)vm._update(vnode,hydrating)mark(endTag)measure(`vue${name}patch`,startTag,endTag)}}else{updateComponent=()=>{vm._update(vm._render(),hydrating)}}constwatcherOptions:WatcherOptions={before(){if(vm._isMounted&&!vm._isDestroyed){callHook(vm,'beforeUpdate')}}}if(__DEV__){watcherOptions.onTrack=e=>callHook(vm,'renderTracked',[e])watcherOptions.onTrigger=e=>callHook(vm,'renderTriggered',[e])}wesetthistovm._watcherinsidethewatcher'sconstructorsincethewatcher'sinitialpatchmaycall$forceUpdate(e.g.insidechildcomponent'smountedhook),whichreliesonvm._watcherbeingalreadydefinednewWatcher(vm,updateComponent,noop,watcherOptions,true/*isRenderWatcher*/)hydrating=falseflushbufferforflush:"pre"watchersqueuedinsetup()constpreWatchers=vm._preWatchersif(preWatchers){for(leti=0;i<preWatchers.length;i++){preWatchers[i].run()}}manuallymountedinstance,callmountedonselfmountediscalledforrender-createdchildcomponentsinitsinsertedhookif(vm.$vnode==null){vm._isMounted=truecallHook(vm,'mounted')}returnvm}exportfunctionupdateChildComponent(vm:Component,propsData:Record<string,any>|null|undefined,listeners:Record<string,Function|Array<Function>>|undefined,parentVnode:MountedComponentVNode,renderChildren?:Array<VNode>|null){if(__DEV__){isUpdatingChildComponent=true}determinewhethercomponenthasslotchildrenweneedtodothisbeforeoverwriting$options._renderChildren.checkiftherearedynamicscopedSlots(hand-writtenorcompiledbutwithdynamicslotnames).Staticscopedslotscompiledfromtemplatehasthe"$stable"marker.constnewScopedSlots=parentVnode.data.scopedSlotsconstoldScopedSlots=vm.$scopedSlotsconsthasDynamicScopedSlot=!!((newScopedSlots&&!newScopedSlots.$stable)||(oldScopedSlots!==emptyObject&&!oldScopedSlots.$stable)||(newScopedSlots&&vm.$scopedSlots.$key!==newScopedSlots.$key)||(!newScopedSlots&&vm.$scopedSlots.$key))Anystaticslotchildrenfromtheparentmayhavechangedduringparent'supdate.Dynamicscopedslotsmayalsohavechanged.Insuchcases,aforcedupdateisnecessarytoensurecorrectness.letneedsForceUpdate=!!(renderChildren||hasnewstaticslotsvm.$options._renderChildren||hasoldstaticslotshasDynamicScopedSlot)constprevVNode=vm.$vnodevm.$options._parentVnode=parentVnodevm.$vnode=parentVnodeupdatevm'splaceholdernodewithoutre-renderif(vm._vnode){updatechildtree'sparentvm._vnode.parent=parentVnode}vm.$options._renderChildren=renderChildrenupdate$attrsand$listenershashthesearealsoreactivesotheymaytriggerchildupdateifthechildusedthemduringrenderconstattrs=parentVnode.data.attrs||emptyObjectif(vm._attrsProxy){forceupdateifattrsareaccessedandhaschangedsinceitmaybepassedtoachildcomponent.if(syncSetupProxy(vm._attrsProxy,attrs,(prevVNode.data&&prevVNode.data.attrs)||emptyObject,vm,'$attrs')){needsForceUpdate=true}}vm.$attrs=attrsupdatelistenerslisteners=listeners||emptyObjectconstprevListeners=vm.$options._parentListenersif(vm._listenersProxy){syncSetupProxy(vm._listenersProxy,listeners,prevListeners||emptyObject,vm,'$listeners')}vm.$listeners=vm.$options._parentListeners=listenersupdateComponentListeners(vm,listeners,prevListeners)updatepropsif(propsData&&vm.$options.props){toggleObserving(false)constprops=vm._propsconstpropKeys=vm.$options._propKeys||[]for(leti=0;i<propKeys.length;i++){constkey=propKeys[i]constpropOptions:any=vm.$options.propswtfflow?props[key]=validateProp(key,propOptions,propsData,vm)}toggleObserving(true)keepacopyofrawpropsDatavm.$options.propsData=propsData}resolveslots+forceupdateifhaschildrenif(needsForceUpdate){vm.$slots=resolveSlots(renderChildren,parentVnode.context)vm.$forceUpdate()}if(__DEV__){isUpdatingChildComponent=false}}functionisInInactiveTree(vm){while(vm&&(vm=vm.$parent)){if(vm._inactive)returntrue}returnfalse}exportfunctionactivateChildComponent(vm:Component,direct?:boolean){if(direct){vm._directInactive=falseif(isInInactiveTree(vm)){return}}elseif(vm._directInactive){return}if(vm._inactive||vm._inactive===null){vm._inactive=falsefor(leti=0;i<vm.$children.length;i++){activateChildComponent(vm.$children[i])}callHook(vm,'activated')}}exportfunctiondeactivateChildComponent(vm:Component,direct?:boolean){if(direct){vm._directInactive=trueif(isInInactiveTree(vm)){return}}if(!vm._inactive){vm._inactive=truefor(leti=0;i<vm.$children.length;i++){deactivateChildComponent(vm.$children[i])}callHook(vm,'deactivated')}}exportfunctioncallHook(vm:Component,hook:string,args?:any[],setContext=true){#7573disabledepcollectionwheninvokinglifecyclehookspushTarget()constprev=currentInstancesetContext&&setCurrentInstance(vm)consthandlers=vm.$options[hook]constinfo=`${hook}hook`if(handlers){for(leti=0,j=handlers.length;i<j;i++){invokeWithErrorHandling(handlers[i],vm,args||null,vm,info)}}if(vm._hasHookEvent){vm.$emit('hook:'+hook)}setContext&&setCurrentInstance(prev)popTarget()}