import{ref,computed,watch}from'../../index'import{expectType}from'../utils'constsource=ref('foo')constsource2=computed(()=>source.value)constsource3=()=>1//lazywatcherwillhaveconsistenttypesforoldValue.watch(source,(value,oldValue)=>{expectType<string>(value)expectType<string>(oldValue)})watch([source,source2,source3],(values,oldValues)=>{expectType<[string,string,number]>(values)expectType<[string,string,number]>(oldValues)})//constarraywatch([source,source2,source3]asconst,(values,oldValues)=>{expectType<Readonly<[string,string,number]>>(values)expectType<Readonly<[string,string,number]>>(oldValues)})//immediatewatcher'soldValuewillbeundefinedonfirstrun.watch(source,(value,oldValue)=>{expectType<string>(value)expectType<string|undefined>(oldValue)},{immediate:true})watch([source,source2,source3],(values,oldValues)=>{expectType<[string,string,number]>(values)expectType<[string|undefined,string|undefined,number|undefined]>(oldValues)},{immediate:true})//constarraywatch([source,source2,source3]asconst,(values,oldValues)=>{expectType<Readonly<[string,string,number]>>(values)expectType<Readonly<[string|undefined,string|undefined,number|undefined]>>(oldValues)},{immediate:true})//shouldprovidecorrectref.valueinnertypetocallbacksconstnestedRefSource=ref({foo:ref(1)})watch(nestedRefSource,(v,ov)=>{expectType<{foo:number}>(v)expectType<{foo:number}>(ov)})constsomeRef=ref({test:'test'})constotherRef=ref({a:'b'})watch([someRef,otherRef],values=>{constvalue1=values[0]//notypeerrorconsole.log(value1.test)constvalue2=values[1]//notypeerrorconsole.log(value2.a)})